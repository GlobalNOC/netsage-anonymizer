#!/usr/bin/perl

use strict;
use warnings;

use GRNOC::Config;

use MongoDB;
use Devel::Size qw( total_size );
use Getopt::Long;
use JSON::XS;

use Data::Dumper;

my $BATCH_SIZE = 100;

my $end = time;
my $start = $end - 86400 * 30; # 1 day

my $USAGE = "$0 --to <email>";

my $email_to = "";

#GetOptions("to=s" => \$email_to) or die $USAGE;

#if (! $email_to){
#    die $USAGE;
#}

my $config = GRNOC::Config->new(config_file => "/etc/grnoc/tsds/services/config.xml",
				force_array => 0);

my $host = $config->get('/config/mongo/@host');
my $port = $config->get('/config/mongo/@port');
my $user = $config->get('/config/mongo/root');

my $mongo = MongoDB::MongoClient->new(
    host     => "$host:$port",
    username => $user->{'user'},
    password => $user->{'password'}
    );

my $flow_db = $mongo->get_database('flow');

my $json = JSON::XS->new();

my $measurements_count = $flow_db->get_collection('measurements')->count();
my $data_count = $flow_db->get_collection('data')->count();
my $storage_stats = $flow_db->run_command( { dbStats => 1 } );

my $string = "Information for 'flow' database:\n\n";
$string .= "Num Measurement Docs -> $measurements_count\n";
$string .= "Num Data Docs        -> $data_count\n";
$string .= "Sizeof Data bytes    -> $storage_stats->{'dataSize'}\n";
$string .= "Sizeof Storage bytes -> $storage_stats->{'storageSize'}\n";

warn "$string\n";

$string = "";

my $col = $flow_db->get_collection('measurements');
my $data_col = $flow_db->get_collection('data');

my $max_count = 0;
my $max_size = 0;
#my $measurements = $col->find; #->limit(5);
my $filter = {
#    start => { '$gt' => $start, '$lt' => $end },
    #end => { '$lt' => $end } # NOTE: measurement->end seems to be undef in many (all?) cases
    };
#warn "filter " . Dumper $filter;
my $measurements = $col->find( $filter );
my $batch = [];

while (my $doc = $measurements->next) {
    my $row = {};
    #print "doc: " . Dumper $doc;
    my $id = $doc->{'identifier'};
    #warn "identifier: $id";
    #my $data_res = $data_col->find({ identifier => $id })->count;
    my $data_res = $data_col->find(
    { 
        identifier => $id,
#        start => { '$gt' => $start },
#        end => { '$lt' => $end },
    }  );
    #if ( $data_res > $max_count ) {
#		$max_count = $data_res;
#	}
    #warn "count: $data_res";
    my $count = 0;
    my $records = [];
    while (my $value = $data_res->next) {
        push @$records, $value;
        $count++;
    }
    #warn "rrecords" . Dumper $records;
    foreach my $record ( @$records ) {
        $row = $record;
        #warn "record " . Dumper $record;
        $row->{'meta'} = $doc;
        #warn "before changes " . Dumper $row;
        $row = _prepare_data( $row );
        #print "after changes " . Dumper $row;
        my $size = total_size( $row );
        #warn "row size: $size";
        #die;
        #warn "data_res: " . Dumper $data_res;
        if ( $size > $max_size ) {
            $max_size = $size;

        }
    }
    _output_archive( $row );
    #push @$batch, $row;
    #warn "row " . Dumper $row;
    #if ( @$batch >= $BATCH_SIZE ) {
    #    _output_archive( $batch );
    #    $batch = [];
    #}
}

# output remaining messages
if ( @$batch > 0 ) {
    _output_archive( $batch );
}


warn "max count: $max_count; max size: $max_size";
#warn "measurements " . Dumper $measurements;

sub _prepare_data {
	my $row = shift;
	$row = _cleanup_extra_fields( $row );
    delete $row->{'meta'}->{'start'};
    delete $row->{'meta'}->{'end'};
	return $row;
}

# recursively clean up extra fields
# delete _id field
sub _cleanup_extra_fields {
    my $obj = shift;
    foreach my $key ( keys %$obj ) {
        my $val = $obj->{$key};
        next if not defined $val;
        if ( ref($val) eq 'HASH' ) { 
            # recurse
            $val = _cleanup_extra_fields( $val );
        } elsif ( ref($val) eq 'ARRAY' ) {
            for(my $i=0; $i<@$val;$i++) {
                $val->[$i] = _cleanup_extra_fields( $val->[$i] );
            }
        } else {
            delete $obj->{'_id'};
            delete $obj->{'identifier'};
            delete $obj->{'updated_start'};
            delete $obj->{'updated_end'};
        }
    }

    return $obj;
}

sub _output_archive {
    my $data = shift;
    my $output = $json->encode( $data );
    print "$output\n";

}

