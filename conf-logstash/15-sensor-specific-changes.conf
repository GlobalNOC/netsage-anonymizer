# Make changes required for specific sensors
# Parameters are obtained from an environment file (/etc/logstash/logstash-env-vars - see the logstash systemd file). 
# If values are not provided, the defaults following the :'s are used (flags will be False, so nothing will happen).
# With a bare-metal installation, you may also just edit this file appropriately.

filter {

      #---- Change the sensor name for flows from a certain interface (ifindex) 
      mutate {
          add_field => { "[@metadata][ifindex_sensor_rename_flag]"     => "${ifindex_sensor_rename_flag:False}" }
          add_field => { "[@metadata][ifindex_sensor_rename_old_name]" => "${ifindex_sensor_rename_old_name:oldname}" }
          add_field => { "[@metadata][ifindex_sensor_rename_new_name]" => "${ifindex_sensor_rename_new_name:newname}" }
          add_field => { "[@metadata][ifindex_sensor_rename_ifindex]"  => "${ifindex_sensor_rename_ifindex:1}" }
          id => "15-1"
      }
      if [@metadata][ifindex_sensor_rename_flag] == "True" and [meta][sensor_id] == [@metadata][ifindex_sensor_rename_old_name]
      and ( [meta][src_ifindex] == [@metadata][ifindex_sensor_rename_ifindex] or [meta][dst_ifindex] == [@metadata][ifindex_sensor_rename_ifindex] ) {
          mutate {
              replace => { "[meta][sensor_id]" => "%{[@metadata][ifindex_sensor_rename_new_name]}" }
              id => "15-2"
          }
      }

      #---- Manually account for sampling for listed sensors in case the sensor is not sending the right info.
      # For netflow, a sampling rate correction can be done here or in the nfsen config or nfcapd command using the -s option.
      # For sflow, there is no such option, so it must be done here. 
      # Provide a comma-separated list of sensor names to match and the correction factor (eg, for sampling 1 out of 100, enter 100)
      mutate {
         add_field => { "[@metadata][sampling_correction_flag]"    => "${sampling_correction_flag:False}" }
         add_field => { "[@metadata][sampling_correction_sensors]" => "${sampling_correction_sensors:sensor1,sensor2}" }
         add_field => { "[@metadata][sampling_correction_factor]"  => "${sampling_correction_factor:1}" }
	 # make the field into an array  (if this runs into problems, 'in' can also test for a substring in a string)
         split =>     { "[@metadata][sampling_correction_sensors]" => "," }           
         id => "15-3"
      }
      if [@metadata][sampling_correction_flag] == "True" and [meta][sensor_id] in [@metadata][sampling_correction_sensors] {
         ruby {
             code => "
                  correction_factor = event.get('[@metadata][sampling_correction_factor]').to_i
                  event.set('[values][num_bits]',      correction_factor * event.get('[values][num_bits]').to_i)
                  event.set('[values][num_packets]',   correction_factor * event.get('[values][num_packets]').to_i)
                  event.set('[values][bits_per_second]',    correction_factor * event.get('[values][bits_per_second]').to_i)
                  event.set('[values][packets_per_second]', correction_factor * event.get('[values][packets_per_second]').to_i)
             "
             id => "15-4"
         }
      }

}
