filter {
  if [type] == 'flow' {
    # preserve timestamp values
    mutate {
      add_field => {
        'start_timestamp' => '%{[start]}'
        'end_timestamp'   => '%{[end]}'
      }
    }

    # convert strings to numeric types where appropriate
    mutate {
      convert => {
        '[start_timestamp]'            => 'float'
        '[end_timestamp]'              => 'float'

        '[meta][src_asn]'              => 'integer'
        '[meta][dst_asn]'              => 'integer'

        '[meta][src_port]'             => 'integer'
        '[meta][dst_port]'             => 'integer'

        '[values][duration]'           => 'float'
        '[values][num_bits]'           => 'integer'
        '[values][num_packets]'        => 'integer'
        '[values][bits_per_second]'    => 'integer'
        '[values][packets_per_second]' => 'integer'
      }
    }

    # convert timestamps in ms to s
    ruby {
      code => "
        xstart = event.get('start_timestamp')
        xend = event.get('end_timestamp')
        event.set('start_timestamp', xstart/1000) if xstart > 9999999999
        event.set('end_timestamp', xend/1000) if xend > 9999999999
      "
    }

    # convert timestamps to date fields
    date {
      match  => [ '[start_timestamp]', 'UNIX' ]
      target => '[start]'
    }

    date {
      match  => [ '[end_timestamp]' ,'UNIX' ]
      target => '[end]'
    }
  }
}
