filter {
  if [type] == 'flow' {

    # copy timestamp values
    mutate {
      add_field => {
        'start_timestamp' => '%{[start]}'
        'end_timestamp'   => '%{[end]}'
      }
    }

    # convert strings to numeric types where appropriate (timestamps must be to floats, not ints)
    mutate {
      convert => {
        '[start_timestamp]'            => 'float'
        '[end_timestamp]'              => 'float'

        '[meta][src_asn]'              => 'integer'
        '[meta][dst_asn]'              => 'integer'

        '[meta][src_port]'             => 'integer'
        '[meta][dst_port]'             => 'integer'

        '[values][duration]'           => 'float'
        '[values][num_bits]'           => 'integer'
        '[values][num_packets]'        => 'integer'
        '[values][bits_per_second]'    => 'float'
        '[values][packets_per_second]' => 'float'
      }
    }

    # convert any timestamps in ms to s
    ruby {
      code => "
        xstart = event.get('start_timestamp')
        xend = event.get('end_timestamp')
        event.set('start_timestamp', xstart/1000) if xstart > 9999999999
        event.set('end_timestamp', xend/1000) if xend > 9999999999
      "
    }

    # injest_time (will equal @timestamp if aggregation is not done)
    mutate {
      add_field => {
        @injest_time = Time.now
      }
    }

  }
}
